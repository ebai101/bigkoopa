import os
import base64
import asyncio
import typing_json as json
from pprint import pprint as pp
from typing import TypedDict, Callable

packet_types = ['eval', 'eval_r', 'wakeup', 'wakeup_r']


def generate_nonce() -> str:
    return base64.b64encode(os.urandom(8), altchars=b'-_').decode('utf-8')


# packet format for turtle communication
# spec:
#     turtle_id = id of target turtle
#     type = packet type, from packet_types. _r suffix means response
#     data = command payload for outgoing, response value for incoming
#     nonce = autogenerated nonce unique to each comand/response pair
class TurtlePacket(TypedDict):
    turtle_id: int
    type: str
    data: str
    nonce: str


class TurtleSwarm:

    def __init__(self):
        self.turtle_list = []
        self.command_list = []

    # sends a wakeup broadcast and waits until timeout for responses
    # adds each reponse's t_id to the turtle list
    def wakeup_turtles(self):
        pass

    def add_command(self, command: dict[str, str]):
        self.command_list.append(command)

    def execute(self, func: Callable):
        func()
        pp(self.command_list)


# turtle api functions
class TurtleAPI:

    def __init__(self, swarm: TurtleSwarm):
        self.swarm = swarm

    def forward(self):
        self.swarm.add_command({
            'type': 'eval',
            'data': 'return turtle.forward()',
            'nonce': generate_nonce()
        })

    def back(self):
        self.swarm.add_command({
            'type': 'eval',
            'data': 'return turtle.back()',
            'nonce': generate_nonce()
        })

    def up(self):
        self.swarm.add_command({
            'type': 'eval',
            'data': 'return turtle.up()',
            'nonce': generate_nonce()
        })

    def down(self):
        self.swarm.add_command({
            'type': 'eval',
            'data': 'return turtle.down()',
            'nonce': generate_nonce()
        })
